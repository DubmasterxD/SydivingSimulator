using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Falling : MonoBehaviour {

    private readonly int x = 0, y = 1;

    //variables
    public Vector3 location = new Vector3(0, 4000, 0);              // position of jumper [m]
    public Vector3 velocity = new Vector3(45, 0, 0);                // velocity of jumper [m/s]
    private Vector3 acceleration = new Vector3(0, 0, 0);            // acceleration of jumper [m/s^2]
    private float gravity;                                          // earths gravitation acceleration [m/s^2]
    private float airDensity;                                       // density of air in jumpers location
    private float temperature;                                      // approximate temperature in jumpers location [K]
    private float pressure;                                         // approximate atmospheric pressure in jumpers location [Pa]private float liftCoefficient;
    private float dragCoefficient;                                  // used to quantify the drag or resistance of an object in a fluid environment
    private float liftCoefficient;                                  // relates the lift generated by a lifting body to the fluid density around the body, the fluid velocity and an associated reference area
    private float dragProjectedArea;                                // area projected parallel to velocity vector
    private float liftProcejtedArea;                                // area projected perpendicular to velocity vector
    private float angleOfAttack;                                    // angle between reference line and velocity vector
    private float alpha;                                            // angle between velocity vector and horizontal line
    private Vector3 referenceLineDirection = new Vector3(1, 0, 0);  // line that indicates the position of a jumper's body

    // constant variables
    public float latitude;                                          // approximate latitude of a jump [°]
    private float radius;                                           // approximate Earth's radius in jumps latitude [m]
    public float mass;                                              // mass of a jumper [kg]
    public float frontArea;                                         // projected area of a jumper from the front
    public float topArea;                                           // projected area of a jumper from the top

    // constants
    private readonly float gravitationalConstant = 6.67408f * Mathf.Pow(10, -11);           // Gravitatinal constant [m^3/(kg*s^2)]
    private readonly float earthMass = 5.97237f * Mathf.Pow(10, 24);                        // mass of the earth [kg]
    private readonly float polarRadius = 6356752f;                                          // earths polar radius [m]
    private readonly float equatorialRadius = 6378137f;                                     // earths equatorial radius [m]
    private readonly float airMolarMass = 0.0289644f;                                       // molar mass of dry air [kg/mol]
    private readonly float gasConstant = 8.31447f;                                          // ideal (universal) gas constant [J/(mol*K)]
    private readonly float standardTemperature = 288.15f;                                   // sea level standard temperature [K]
    private readonly float standardPressure = 101325f;                                      // sea level standard atmospheric pressure [Pa]
    private readonly float temperatureLapseRate = 0.0065f;                                  // temperature lapse rate [K/m] (rate at which temperature in Earth's atmosphere decreases with an increase in altitude)

    // Use this for initialization
    void Start ()
    {
        // y = y0 + (x - x0)*(y1 - y0)/(x1 - x0)
        radius = equatorialRadius + latitude * (polarRadius - equatorialRadius) / 90;

        //testing
        dragCoefficient = 1;
        liftCoefficient = 1;
        latitude = 0;
        mass = 70;
        frontArea = 1;
        topArea = 0.3f;
	}
	
	// Update is called once per frame
	void Update ()
    {
        Debug.Log("Położenie : " + location[x] + ", " + location[y] + "\nPrędkość : " + velocity[x] + ", " + velocity[y]);
        Debug.Log("Terminal velocity : " + (Mathf.Sqrt(2 * mass * gravity / (airDensity * (dragCoefficient * dragProjectedArea + liftCoefficient * liftProcejtedArea)))));

        // g = G * M / r^2
        gravity = gravitationalConstant * earthMass / Mathf.Pow(radius + location[y], 2);
        // T = T0 - L * h
        temperature = standardTemperature - temperatureLapseRate * location[y];
        // p = p0 * (1 - L * h / T0)^((g * Ma) / (R * L))
        pressure = standardPressure * Mathf.Pow(1 - temperatureLapseRate * location[y] / standardTemperature, (gravity * airMolarMass) / (gasConstant * temperatureLapseRate));
        // rho = (p * Ma) / (R * T)
        airDensity = (pressure * airMolarMass) / (gasConstant * temperature);
        // The cosine of the angle between two vectors is equal to the dot product of this vectors divided by the product of vector magnitude.
        angleOfAttack = Mathf.Acos((velocity[x] * referenceLineDirection[x] + velocity[y] * referenceLineDirection[y]) / (Mathf.Sqrt(Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * Mathf.Sqrt(Mathf.Pow(referenceLineDirection[x], 2) + Mathf.Pow(referenceLineDirection[y], 2))));
        alpha = Mathf.Acos(velocity[x] / (Mathf.Sqrt(Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2))));
        // A = a * cos(alfa) + b * sin(alfa)
        dragProjectedArea = topArea * Mathf.Cos(angleOfAttack) + frontArea * Mathf.Sin(angleOfAttack);
        // B = a * sin(alfa) + b * cos(alfa)
        liftProcejtedArea = topArea * Mathf.Sin(angleOfAttack) + frontArea * Mathf.Cos(angleOfAttack);
        // ay = v^2 * rho * (sin(alfa) * Cd * A + cos(alfa) * Cl * B) / (2 * m) - g
        acceleration[y] = (Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * airDensity / (2 * mass) * (Mathf.Sin(alpha) * dragCoefficient * dragProjectedArea + Mathf.Cos(alpha) * liftCoefficient * liftProcejtedArea) - gravity;
        // ax = v^2 * rho * (-cos(alfa) * Cd * A + sin(alfa) * Cl * B) / (2 * m)
        acceleration[x] = (Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * airDensity / (2 * mass) * (-1 * Mathf.Cos(alpha) * dragCoefficient * dragProjectedArea + Mathf.Sin(alpha) * liftCoefficient * liftProcejtedArea);
        // x(t + dt) = x(t) + vx(t) * dt
        location[x] += velocity[x] * Time.deltaTime;
        // y(t + dt) = y(t) + vy(t) * dt
        location[y] += velocity[y] * Time.deltaTime;
        // vy(t + dt) = vy(t) + Fy(t) * dt / m
        velocity[x] += acceleration[x] * Time.deltaTime;
        // vx(t + dt) = vx(t) + Fx(t) * dt / m
        velocity[y] += acceleration[y] * Time.deltaTime;
    }
}
