using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Falling : MonoBehaviour
{
    private readonly int x = 0, y = 1;
    public bool cameraFollows;
    private float timePassedSinceJump = 0;                          // [s]

    // Variables
    public Vector3 jumpersLocation = new Vector3(0, 4000, 0);       // [m]
    public Vector3 jumpersVelocity = new Vector3(45, 0, 0);         // [m/s]
    private Vector3 jumpersAcceleration = new Vector3(0, 0, 0);     // [m/(s^2)]
    public Vector3 jumpersRotation = new Vector3(90, 90, 0);        // [°]
    private float earthGravity;                                     // [m/(s^2)]
    private float currAirDensity;                                   // [kg/(m^3)]
    private float currTemperature;                                  // [K]
    private float currAtmosphericPressure;                          // [Pa]
    private float dragCoefficient;                                  // Used to quantify the drag or resistance of an object in a fluid environment
    private float liftCoefficient;                                  // Relates the lift generated by a lifting body to the fluid density around the body, the fluid velocity and an associated reference area
    private float dragProjectedArea;                                // Area projected parallel to velocity vector [m^2]
    private float liftProcejtedArea;                                // Area projected perpendicular to velocity vector [m^2]
    private float alpha;                                            // Angle between velocity vector and horizontal line [°]
    private Vector3 referenceLineDirection = new Vector3(1, 0, 0);  // Line that indicates the position of a jumper's body
    private float earthRadius;                                      // [m]
    private float jumpersLatitude;                                  // [°]
    private float jumpersMass;                                      // [kg]
    public float angleOfAttack { set; get; }                        // Angle between reference line and velocity vector [°]
    public float jumpersFrontProjectedArea { set; get; }            // [m^2]
    public float jumpersTopProjectedArea { set; get; }              // [m^2]

    // Constants
    private readonly float gravitationalConstant = 6.67408f * Mathf.Pow(10, -11);   // [m^3/(kg*s^2)]
    private readonly float earthMass = 5.97237f * Mathf.Pow(10, 24);                // [kg]
    private readonly float earthPolarRadius = 6356752f;                             // [m]
    private readonly float earthEquatorialRadius = 6378137f;                        // [m]
    private readonly float dryAirMolarMass = 0.0289644f;                            // [kg/mol]
    private readonly float idealGasConstant = 8.31447f;                             // [J/(mol*K)]
    private readonly float seaLevelStandardTemperature = 288.15f;                   // [K]
    private readonly float seaLevelStandardAtmosphericPressure = 101325f;           // [Pa]
    private readonly float temperatureLapseRate = 0.0065f;                          // [K/m] rate at which temperature in Earth's atmosphere decreases with an increase in altitude
    private readonly float maxDragCoefficient = 1.0f;
    private readonly float minDragCoefficient = 0.7f;
    private readonly float maxLiftCoefficient = 0.2f;

    // References
    private Rigidbody rb;
    private Animator anim;
    private Camera cam;

    void Start()
    {
        jumpersLatitude = GameController.instance.jumpersLatitude;
        jumpersVelocity[x] = GameController.instance.planeSpeed;
        jumpersLocation[y] = GameController.instance.startingAltitude;
        jumpersMass = GameController.instance.jumpersMass;
        rb = GetComponent<Rigidbody>();
        anim = GetComponent<Animator>();
        cam = GetComponentInChildren<Camera>();
        // If starting velocity is 0, set is to be almost 0
        if (jumpersVelocity[x] == 0 && jumpersVelocity[y] == 0)
        {
            jumpersVelocity[y] = 0.0000000000000001f;
        }
        // y = y0 + (x - x0)*(y1 - y0)/(x1 - x0)
        earthRadius = earthEquatorialRadius + jumpersLatitude * (earthPolarRadius - earthEquatorialRadius) / 90;

        // Testing
    }
    
    void FixedUpdate()
    {
        if (GameController.instance.gameRunning)
        {
            SaveLocationToFile();

            CalculateVariables();
            
            CalculateLocation();

            // Locates jumper in the right position on the map
            rb.transform.SetPositionAndRotation(jumpersLocation, Quaternion.Euler(jumpersRotation));

            SetAnimationFrame();

            // Adjusting camera rotation and position to follow speed vector
            if (cameraFollows)
            {
                FollowCamera();
            }
        }
    }

    private void CalculateVariables()
    {   
        // g = G * M / r^2
        earthGravity = gravitationalConstant * earthMass / Mathf.Pow(earthRadius + jumpersLocation[y], 2);
        // T = T0 - L * h
        currTemperature = seaLevelStandardTemperature - temperatureLapseRate * jumpersLocation[y];
        // p = p0 * (1 - L * h / T0)^((g * Ma) / (R * L))
        currAtmosphericPressure = seaLevelStandardAtmosphericPressure * Mathf.Pow(1 - temperatureLapseRate * jumpersLocation[y] / seaLevelStandardTemperature, (earthGravity * dryAirMolarMass) / (idealGasConstant * temperatureLapseRate));
        // rho = (p * Ma) / (R * T)
        currAirDensity = (currAtmosphericPressure * dryAirMolarMass) / (idealGasConstant * currTemperature);
        // Calculating current reference line taken from rotation of skydiver. Having the rotation I use y=ax, where a is tan(rotation),
        // and put some value to x so I can calculate y and therefore direction of reference line. 
        // But I need to make sure that the rotation is neither 0 nor 180 for tan
        if (jumpersRotation[x] == 0)
        {
            referenceLineDirection = new Vector3(0, 1, 0);
        }
        else if (jumpersRotation[x] == 180)
        {
            referenceLineDirection = new Vector3(0, -1, 0);
        }
        else
        {
            referenceLineDirection[x] = 1;
            referenceLineDirection[y] = referenceLineDirection[x] / Mathf.Tan(Mathf.Deg2Rad * jumpersRotation[x]);
            if (Mathf.Abs(referenceLineDirection[y]) < 0.001f)
            {
                referenceLineDirection[y] = 0;
            }
        }
        // The cosine of the angle between two vectors is equal to the dot product of this vectors divided by the product of vector magnitude.
        angleOfAttack = Mathf.Acos(Mathf.Clamp((jumpersVelocity[x] * referenceLineDirection[x] + jumpersVelocity[y] * referenceLineDirection[y]) / (Mathf.Sqrt(Mathf.Pow(jumpersVelocity[x], 2) + Mathf.Pow(jumpersVelocity[y], 2)) * Mathf.Sqrt(Mathf.Pow(referenceLineDirection[x], 2) + Mathf.Pow(referenceLineDirection[y], 2))), -1.0f, 1.0f));
        if ((jumpersVelocity.normalized.y > referenceLineDirection.normalized.y && jumpersVelocity.y < 0) || (jumpersVelocity.normalized.y < referenceLineDirection.normalized.y && jumpersVelocity.y > 0))
        {
            angleOfAttack *= -1;
        }
        alpha = Mathf.Acos(jumpersVelocity[x] / (Mathf.Sqrt(Mathf.Pow(jumpersVelocity[x], 2) + Mathf.Pow(jumpersVelocity[y], 2))));
        // A = a * cos(alfa) + b * sin(alfa)
        dragProjectedArea = Mathf.Abs(jumpersTopProjectedArea * Mathf.Cos(angleOfAttack)) + Mathf.Abs(jumpersFrontProjectedArea * Mathf.Sin(angleOfAttack));
        // B = a * sin(alfa) + b * cos(alfa)
        liftProcejtedArea = Mathf.Abs(jumpersTopProjectedArea * Mathf.Sin(angleOfAttack)) + Mathf.Abs(jumpersFrontProjectedArea * Mathf.Cos(angleOfAttack));

        dragCoefficient = ( -Mathf.Cos(angleOfAttack*2) * (maxDragCoefficient - minDragCoefficient) + maxDragCoefficient + minDragCoefficient) / 2;
        liftCoefficient = Mathf.Sin(angleOfAttack * 2) * maxLiftCoefficient;
    }

    private void CalculateLocation()
    {
        // ay = v^2 * rho * (sin(alfa) * Cd * A + cos(alfa) * Cl * B) / (2 * m) - g
        jumpersAcceleration[y] = (Mathf.Pow(jumpersVelocity[x], 2) + Mathf.Pow(jumpersVelocity[y], 2)) * currAirDensity / (2 * jumpersMass) * (Mathf.Sin(alpha) * dragCoefficient * dragProjectedArea + Mathf.Cos(alpha) * liftCoefficient * liftProcejtedArea) - earthGravity;
        // ax = v^2 * rho * (-cos(alfa) * Cd * A + sin(alfa) * Cl * B) / (2 * m)
        jumpersAcceleration[x] = (Mathf.Pow(jumpersVelocity[x], 2) + Mathf.Pow(jumpersVelocity[y], 2)) * currAirDensity / (2 * jumpersMass) * (-1 * Mathf.Cos(alpha) * dragCoefficient * dragProjectedArea + Mathf.Sin(alpha) * liftCoefficient * liftProcejtedArea);
        // vx(t + dt) = vx(t) + Fx(t) * dt / m
        jumpersVelocity[x] += jumpersAcceleration[x] * Time.fixedDeltaTime;
        // vy(t + dt) = vy(t) + F(t) * dt / m
        jumpersVelocity[y] += jumpersAcceleration[y] * Time.fixedDeltaTime;
        // x(t + dt) = x(t) + vx(t) * dt
        jumpersLocation[x] += jumpersVelocity[x] * Time.fixedDeltaTime;
        // y(t + dt) = y(t) + vy(t) * dt
        jumpersLocation[y] += jumpersVelocity[y] * Time.fixedDeltaTime;
    }

    private void SetAnimationFrame()
    {
        // Using angle of attack to adjust animation
        angleOfAttack = angleOfAttack * Mathf.Rad2Deg * 3 / 2;
        if (angleOfAttack > 30)
        {
            angleOfAttack = 30;
        }
        if (angleOfAttack < 0)
        {
            angleOfAttack = 0;
        }
        anim.Play("Fall", 0, (30f - angleOfAttack) / 30.0f);
    }

    private void FollowCamera()
    {
        if (jumpersVelocity[x] != 0)
        {
            cam.gameObject.transform.localRotation = Quaternion.Euler(-90 - Mathf.Rad2Deg * Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x]), 0, 0);
            cam.gameObject.transform.localPosition = new Vector3(0, -300 * Mathf.Cos(Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x])) + 150, -70 + 300 * Mathf.Sin(Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x])));
        }
    }

    private void SaveLocationToFile()
    {
        timePassedSinceJump += Time.fixedDeltaTime;
        if (timePassedSinceJump >= 1)
        {
            SaveFlightPath.dataToSave += "\n" + jumpersLocation[x] + ";" + jumpersLocation[y];
            timePassedSinceJump = 0;
        }
    }
}
