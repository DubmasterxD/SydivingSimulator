using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Falling : MonoBehaviour {

    private readonly int x = 0, y = 1;
    private Rigidbody rb;
    private Animator anim;
    public bool followCamera;

    //variables
    public Vector3 location = new Vector3(0, 4000, 0);              // position of jumper [m]
    public Vector3 velocity = new Vector3(45, 0, 0);                // velocity of jumper [m/s]
    private Vector3 acceleration = new Vector3(0, 0, 0);            // acceleration of jumper [m/s^2]
    private float gravity;                                          // earths gravitation acceleration [m/s^2]
    private float airDensity;                                       // density of air in jumpers location
    private float temperature;                                      // approximate temperature in jumpers location [K]
    private float pressure;                                         // approximate atmospheric pressure in jumpers location [Pa]private float liftCoefficient;
    private float dragCoefficient;                                  // used to quantify the drag or resistance of an object in a fluid environment
    private float liftCoefficient;                                  // relates the lift generated by a lifting body to the fluid density around the body, the fluid velocity and an associated reference area
    private float dragProjectedArea;                                // area projected parallel to velocity vector
    private float liftProcejtedArea;                                // area projected perpendicular to velocity vector
    private float angleOfAttack;                                    // angle between reference line and velocity vector
    private float alpha;                                            // angle between velocity vector and horizontal line
    private Vector3 referenceLineDirection = new Vector3(1, 0, 0);  // line that indicates the position of a jumper's body

    // constant variables
    public float latitude;                                          // approximate latitude of a jump [°]
    private float radius;                                           // approximate Earth's radius in jumps latitude [m]
    public float mass;                                              // mass of a jumper [kg]
    public float frontArea;                                         // projected area of a jumper from the front
    public float topArea;                                           // projected area of a jumper from the top

    // constants
    private readonly float gravitationalConstant = 6.67408f * Mathf.Pow(10, -11);           // Gravitatinal constant [m^3/(kg*s^2)]
    private readonly float earthMass = 5.97237f * Mathf.Pow(10, 24);                        // mass of the earth [kg]
    private readonly float polarRadius = 6356752f;                                          // earths polar radius [m]
    private readonly float equatorialRadius = 6378137f;                                     // earths equatorial radius [m]
    private readonly float airMolarMass = 0.0289644f;                                       // molar mass of dry air [kg/mol]
    private readonly float gasConstant = 8.31447f;                                          // ideal (universal) gas constant [J/(mol*K)]
    private readonly float standardTemperature = 288.15f;                                   // sea level standard temperature [K]
    private readonly float standardPressure = 101325f;                                      // sea level standard atmospheric pressure [Pa]
    private readonly float temperatureLapseRate = 0.0065f;                                  // temperature lapse rate [K/m] (rate at which temperature in Earth's atmosphere decreases with an increase in altitude)

    // Use this for initialization
    void Start ()
    {
        // if starting velocity is 0, set is to be the lowest possible number, that won't break the code
        if(velocity[x]==0&&velocity[y]==0)
        {
            velocity[y] = 0.000000000000000000001f;
        }
        // y = y0 + (x - x0)*(y1 - y0)/(x1 - x0)
        radius = equatorialRadius + latitude * (polarRadius - equatorialRadius) / 90;

        rb = GetComponent<Rigidbody>();
        anim = GetComponent<Animator>();

        //testing
        dragCoefficient = 0.9f;
        liftCoefficient = 0.05f;
	}
	
	// Update is called once per frame
	void Update ()
    {
        // g = G * M / r^2
        gravity = gravitationalConstant * earthMass / Mathf.Pow(radius + location[y], 2);
        // T = T0 - L * h
        temperature = standardTemperature - temperatureLapseRate * location[y];
        // p = p0 * (1 - L * h / T0)^((g * Ma) / (R * L))
        pressure = standardPressure * Mathf.Pow(1 - temperatureLapseRate * location[y] / standardTemperature, (gravity * airMolarMass) / (gasConstant * temperatureLapseRate));
        // rho = (p * Ma) / (R * T)
        airDensity = (pressure * airMolarMass) / (gasConstant * temperature);
        // calculating current reference line taken from rotation of skydiver. Having the rotation I use y=ax, where a is tan(rotation),
        // and put some value to x so I can calculate y and therefore direction of reference line. 
        // but I need to make sure that the rotation is neither 0 nor 180 for tan
        if (transform.rotation.eulerAngles.x == 0)
        {
            referenceLineDirection = new Vector3(0, 1, 0);
        }
        else if (transform.rotation.eulerAngles.x == 180)
        {
            referenceLineDirection = new Vector3(0, -1, 0);
        }
        else
        {
            referenceLineDirection[x] = 1;
            referenceLineDirection[y] = referenceLineDirection[x] * Mathf.Tan(Mathf.Deg2Rad * transform.rotation.eulerAngles.x);
            if(referenceLineDirection[y]<Mathf.Abs(0.001f))
            {
                referenceLineDirection[y] = 0;
            }
        }
        // The cosine of the angle between two vectors is equal to the dot product of this vectors divided by the product of vector magnitude.
        angleOfAttack = Mathf.Acos((velocity[x] * referenceLineDirection[x] + velocity[y] * referenceLineDirection[y]) / (Mathf.Sqrt(Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * Mathf.Sqrt(Mathf.Pow(referenceLineDirection[x], 2) + Mathf.Pow(referenceLineDirection[y], 2))));
        alpha = Mathf.Acos(velocity[x] / (Mathf.Sqrt(Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2))));
        // A = a * cos(alfa) + b * sin(alfa)
        dragProjectedArea = topArea * Mathf.Cos(angleOfAttack) + frontArea * Mathf.Sin(angleOfAttack);
        // B = a * sin(alfa) + b * cos(alfa)
        liftProcejtedArea = topArea * Mathf.Sin(angleOfAttack) + frontArea * Mathf.Cos(angleOfAttack);
        // ay = v^2 * rho * (sin(alfa) * Cd * A + cos(alfa) * Cl * B) / (2 * m) - g
        acceleration[y] = (Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * airDensity / (2 * mass) * (Mathf.Sin(alpha) * dragCoefficient * dragProjectedArea + Mathf.Cos(alpha) * liftCoefficient * liftProcejtedArea) - gravity;
        // ax = v^2 * rho * (-cos(alfa) * Cd * A + sin(alfa) * Cl * B) / (2 * m)
        acceleration[x] = (Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * airDensity / (2 * mass) * (-1 * Mathf.Cos(alpha) * dragCoefficient * dragProjectedArea + Mathf.Sin(alpha) * liftCoefficient * liftProcejtedArea);
        // x(t + dt) = x(t) + vx(t) * dt
        location[x] += velocity[x] * Time.deltaTime;
        // y(t + dt) = y(t) + vy(t) * dt
        location[y] += velocity[y] * Time.deltaTime;
        // vx(t + dt) = vx(t) + Fx(t) * dt / m
        velocity[x] += acceleration[x] * Time.deltaTime;
        // vy(t + dt) = vy(t) + F(t) * dt / m
        velocity[y] += acceleration[y] * Time.deltaTime;



        // locates jumper in the right position on the map
        rb.transform.SetPositionAndRotation(location, rb.rotation);
        // using angle of attack to adjust animation
        angleOfAttack = angleOfAttack * Mathf.Rad2Deg * 3 / 2;
        if(angleOfAttack>30)
        {
            angleOfAttack = 30;
        }
        if(angleOfAttack<0)
        {
            angleOfAttack = 0;
        }
        anim.Play("Fall", 0, (30 - angleOfAttack) / 30.0f);
        // adjusting camera rotation and position to follow speed vector
        if (followCamera)
        {
            if (velocity[x] != 0)
            {
                GetComponentInChildren<Camera>().gameObject.transform.localRotation = Quaternion.Euler(-90 - Mathf.Rad2Deg * Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x]), 0, 0);
                GetComponentInChildren<Camera>().gameObject.transform.localPosition = new Vector3(0, -300 * Mathf.Cos(Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x])) + 150,-70 + 300 * Mathf.Sin(Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x])));
            }
        }
        // distance to surface
        RaycastHit hit = new RaycastHit();
        Physics.Raycast(location, new Vector3(0, -1, 0),out hit);
    }
}
