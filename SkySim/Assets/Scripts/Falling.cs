using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Falling : MonoBehaviour
{
    private readonly int x = 0, y = 1;
    public bool followCamera;

    // Variables
    public Vector3 location = new Vector3(0, 4000, 0);              // Position of jumper [m]
    public Vector3 velocity = new Vector3(45, 0, 0);                // Velocity of jumper [m/s]
    private Vector3 acceleration = new Vector3(0, 0, 0);            // Acceleration of jumper [m/s^2]
    private float gravity;                                          // Earths gravitation acceleration [m/s^2]
    private float airDensity;                                       // Density of air in jumpers location
    private float temperature;                                      // Approximate temperature in jumpers location [K]
    private float pressure;                                         // Approximate atmospheric pressure in jumpers location [Pa]private float liftCoefficient;
    private float dragCoefficient;                                  // Used to quantify the drag or resistance of an object in a fluid environment
    private float liftCoefficient;                                  // Relates the lift generated by a lifting body to the fluid density around the body, the fluid velocity and an associated reference area
    private float dragProjectedArea;                                // Area projected parallel to velocity vector
    private float liftProcejtedArea;                                // Area projected perpendicular to velocity vector
    private float angleOfAttack;                                    // Angle between reference line and velocity vector
    private float alpha;                                            // Angle between velocity vector and horizontal line
    private Vector3 referenceLineDirection = new Vector3(1, 0, 0);  // Line that indicates the position of a jumper's body
    private float radius;                                           // Approximate Earth's radius in jumps latitude [m]
    private float latitude;                                         // Approximate latitude of a jump [°]
    private float mass;                                             // Mass of a jumper [kg]
    private float frontArea;                                        // Projected area of a jumper from the front
    private float topArea;                                          // Projected area of a jumper from the top
    public float AngleOfAttack { set; get; }

    // Constants
    private readonly float gravitationalConstant = 6.67408f * Mathf.Pow(10, -11);           // Gravitatinal constant [m^3/(kg*s^2)]
    private readonly float earthMass = 5.97237f * Mathf.Pow(10, 24);                        // Mass of the earth [kg]
    private readonly float polarRadius = 6356752f;                                          // Earths polar radius [m]
    private readonly float equatorialRadius = 6378137f;                                     // Earths equatorial radius [m]
    private readonly float airMolarMass = 0.0289644f;                                       // Molar mass of dry air [kg/mol]
    private readonly float gasConstant = 8.31447f;                                          // Ideal (universal) gas constant [J/(mol*K)]
    private readonly float standardTemperature = 288.15f;                                   // Sea level standard temperature [K]
    private readonly float standardPressure = 101325f;                                      // Sea level standard atmospheric pressure [Pa]
    private readonly float temperatureLapseRate = 0.0065f;                                  // Temperature lapse rate [K/m] (rate at which temperature in Earth's atmosphere decreases with an increase in altitude)

    // References
    private Rigidbody rb;
    private Animator anim;
    private Camera cam;
    
    void Start()
    {
        latitude = GameController.instance.latitude;
        velocity[x] = GameController.instance.planeSpeed;
        location[y] = GameController.instance.startingAltitude;
        mass = GameController.instance.mass;
        rb = GetComponent<Rigidbody>();
        anim = GetComponent<Animator>();
        cam = GetComponentInChildren<Camera>();
        // If starting velocity is 0, set is to be almost 0
        if (velocity[x] == 0 && velocity[y] == 0)
        {
            velocity[y] = 0.0000000000000001f;
        }
        // y = y0 + (x - x0)*(y1 - y0)/(x1 - x0)
        radius = equatorialRadius + latitude * (polarRadius - equatorialRadius) / 90;

        // Testing
        dragCoefficient = 0.9f;
        liftCoefficient = 0.05f;
        topArea = 0.02f;
        frontArea = 0.5f;
    }
    
    void FixedUpdate()
    {
        if (GameController.instance.gameRunning)
        {
            // g = G * M / r^2
            gravity = gravitationalConstant * earthMass / Mathf.Pow(radius + location[y], 2);
            // T = T0 - L * h
            temperature = standardTemperature - temperatureLapseRate * location[y];
            // p = p0 * (1 - L * h / T0)^((g * Ma) / (R * L))
            pressure = standardPressure * Mathf.Pow(1 - temperatureLapseRate * location[y] / standardTemperature, (gravity * airMolarMass) / (gasConstant * temperatureLapseRate));
            // rho = (p * Ma) / (R * T)
            airDensity = (pressure * airMolarMass) / (gasConstant * temperature);
            // Calculating current reference line taken from rotation of skydiver. Having the rotation I use y=ax, where a is tan(rotation),
            // and put some value to x so I can calculate y and therefore direction of reference line. 
            // But I need to make sure that the rotation is neither 0 nor 180 for tan
            if (transform.rotation.eulerAngles.x == 0)
            {
                referenceLineDirection = new Vector3(0, 1, 0);
            }
            else if (transform.rotation.eulerAngles.x == 180)
            {
                referenceLineDirection = new Vector3(0, -1, 0);
            }
            else
            {
                referenceLineDirection[x] = 1;
                referenceLineDirection[y] = referenceLineDirection[x] * Mathf.Tan(Mathf.Deg2Rad * transform.rotation.eulerAngles.x);
                if (referenceLineDirection[y] < Mathf.Abs(0.001f))
                {
                    referenceLineDirection[y] = 0;
                }
            }
            // The cosine of the angle between two vectors is equal to the dot product of this vectors divided by the product of vector magnitude.
            angleOfAttack = Mathf.Acos((velocity[x] * referenceLineDirection[x] + velocity[y] * referenceLineDirection[y]) / (Mathf.Sqrt(Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * Mathf.Sqrt(Mathf.Pow(referenceLineDirection[x], 2) + Mathf.Pow(referenceLineDirection[y], 2))));
            alpha = Mathf.Acos(velocity[x] / (Mathf.Sqrt(Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2))));
            // A = a * cos(alfa) + b * sin(alfa)
            dragProjectedArea = topArea * Mathf.Cos(angleOfAttack) + frontArea * Mathf.Sin(angleOfAttack);
            // B = a * sin(alfa) + b * cos(alfa)
            liftProcejtedArea = topArea * Mathf.Sin(angleOfAttack) + frontArea * Mathf.Cos(angleOfAttack);
            // ay = v^2 * rho * (sin(alfa) * Cd * A + cos(alfa) * Cl * B) / (2 * m) - g
            acceleration[y] = (Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * airDensity / (2 * mass) * (Mathf.Sin(alpha) * dragCoefficient * dragProjectedArea + Mathf.Cos(alpha) * liftCoefficient * liftProcejtedArea) - gravity;
            // ax = v^2 * rho * (-cos(alfa) * Cd * A + sin(alfa) * Cl * B) / (2 * m)
            acceleration[x] = (Mathf.Pow(velocity[x], 2) + Mathf.Pow(velocity[y], 2)) * airDensity / (2 * mass) * (-1 * Mathf.Cos(alpha) * dragCoefficient * dragProjectedArea + Mathf.Sin(alpha) * liftCoefficient * liftProcejtedArea);
            // x(t + dt) = x(t) + vx(t) * dt
            location[x] += velocity[x] * Time.fixedDeltaTime;
            // y(t + dt) = y(t) + vy(t) * dt
            location[y] += velocity[y] * Time.fixedDeltaTime;
            // vx(t + dt) = vx(t) + Fx(t) * dt / m
            velocity[x] += acceleration[x] * Time.fixedDeltaTime;
            // vy(t + dt) = vy(t) + F(t) * dt / m
            velocity[y] += acceleration[y] * Time.fixedDeltaTime;
            // Locates jumper in the right position on the map
            rb.transform.SetPositionAndRotation(location, rb.rotation);
            // Using angle of attack to adjust animation
            angleOfAttack = angleOfAttack * Mathf.Rad2Deg * 3 / 2;
            if (angleOfAttack > 30)
            {
                angleOfAttack = 30;
            }
            if (angleOfAttack < 0)
            {
                angleOfAttack = 0;
            }
            // Adjusting camera rotation and position to follow speed vector
            if (followCamera)
            {
                if (velocity[x] != 0)
                {
                    cam.gameObject.transform.localRotation = Quaternion.Euler(-90 - Mathf.Rad2Deg * Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x]), 0, 0);
                    cam.gameObject.transform.localPosition = new Vector3(0, -300 * Mathf.Cos(Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x])) + 150, -70 + 300 * Mathf.Sin(Mathf.Atan2(referenceLineDirection[y], referenceLineDirection[x])));
                }
            }
        }
        anim.Play("Fall", 0, (30 - angleOfAttack) / 30.0f);
    }
}
